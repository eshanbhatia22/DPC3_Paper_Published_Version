\section{Prefetcher Configurations}
\label{Config}

This section describes our approach in putting together all the prefetching 
components across the cache hierarchies.

\subsection{Single-Core Configuration}
\label{Config-Single}

\noindent \textbf{L1D Cache:}
For the L1D Cache we are using a modified version of the next-line prefetcher [cite].
\textcolor{blue}{
- Gino to add details about the modification.
- I might add page balancing idea here.
}
All the prefetch suggestions coming from the L1D prefetcher are being placed in L1D Cache.

\noindent \textbf{L2C Cache:}
For the L2C, we are using the enhaced SPP+PPF approach described in the previous section.
\textcolor{blue}{
- Talk about ignoring previous level's prefetch misses or not
}
Prefetches originating from the L2C can be placed in L2C or LLC, depending on the confidence
estimate given by the perceptron sum.

\noindent \textbf{LLC Cache:}
\textcolor{blue}{
- Next Line vs Next Line Throttled
}

\subsection{Single-Core Complexity}
\label{Config-Complex}

Table XX\% shows a detailed analysis of the hardware overhead required to implement the three 
prefetchers. It is well within the championship budget of 64KBs. In terms of L2C prefetcher's logical 
complexity, SPP is a cascade of three tables, with the output of one indexing into the next.
Constructing the signature only requires simple operations like shifting and XOR. PPF requires
parallel indexing into nine different tables and adding nine 5-bit integers. Weight updates are
done only in steps of +1 or -1.


\subsection{Multi-Core Configuration}
\label{Config-Multi}

In multi-core, we are only using the L2C Prefetcher as described above. It was observed that
the efficient filtering mechanism in PPF helps avoid pollution in the shared LLC. In terms of
complexity, since multi-core implementation is a subset of our single-core implementation, 
it can easily be implemented within the championship rules.
