\section{Prefetcher Configurations}
\label{Config}

This section describes our approach in putting together all the prefetching 
components across the cache hierarchies.

\subsection{Single-Core Configuration}
\label{Config-Single}

\noindent \textbf{L1D Cache:}
For the L1D Cache we are using a modified version of the next-line prefetcher [cite].

The next line prefetcher is modified to have a small table containing the last 
block accessed by a page. indexed by hashing the page number of an access.
When an access occurs, the current block access and the previous access are compared.
If the delta between accesses is +1, then a score table is indexed by the page number and
its value increased. If the delta is not +1, it is decreased. When prefetching, the score table is 
accessed and if the value is above a specified threshold, the next cache line after the access is 
prefetched. This throttling allows for the prefetcher to be aware if the page is susceptible
to multiple +1 deltas, usually consecutively. If the page does not benefit from next line prefetching,
the prefetcher is turned off so that it does not risk polluting the L1D and wrongfully evicting
data that is more beneficial to performance.

\textcolor{blue}{
- I might add page balancing idea here.
}
All the prefetch suggestions coming from the L1D prefetcher are being placed in L1D Cache.

\noindent \textbf{L2C Cache:}
For the L2C, we are using the enhaced SPP+PPF approach described in the previous section.
\textcolor{blue}{
- Talk about ignoring previous level's prefetch misses or not
}
Prefetches originating from the L2C can be placed in L2C or LLC, depending on the confidence
estimate given by the perceptron sum.

\noindent \textbf{LLC Cache:}
\textcolor{blue}{
- Next Line vs Next Line Throttled
}

\subsection{Single-Core Complexity}
\label{Config-Complex}

Table XX\% shows a detailed analysis of the hardware overhead required to implement the three 
prefetchers. It is well within the championship budget of 64KBs. In terms of L2C prefetcher's logical 
complexity, SPP is a cascade of three tables, with the output of one indexing into the next.
Constructing the signature only requires simple operations like shifting and XOR. PPF requires
parallel indexing into nine different tables and adding nine 5-bit integers. Weight updates are
done only in steps of +1 or -1.


\subsection{Multi-Core Configuration}
\label{Config-Multi}

In multi-core, we are only using the L2C Prefetcher as described above. It was observed that
the efficient filtering mechanism in PPF helps avoid pollution in the shared LLC. In terms of
complexity, since multi-core implementation is a subset of our single-core implementation, 
it can easily be implemented within the championship rules.
